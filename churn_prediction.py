# -*- coding: utf-8 -*-
"""CHURN Prediction

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1KAGumWL-CPGe2jmFXD-jj9OOwcFy-JAz
"""

#Importing essential libraries.
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from google.colab import files
plt.style.use("ggplot")

#Uploading the dataset to Google Colab.
upload = files.upload()

df_raw = pd.read_csv("customer_churn_data.csv")

df_raw.head(20)

df_raw.info()

df_raw.shape

df = df_raw.copy()

df.isnull().sum()

#Looking at how Contract Type, Internet Service, and Churn relate with each other.
df[["ContractType","InternetService", "Churn"]].value_counts(normalize= True)

#Checking if there are any missing values in the InternetService column.
df[["InternetService"]].isna().sum().value_counts(normalize = True)

#Filling missing InternetService values with "No Internet".
df["InternetService"].fillna("No Internet", inplace = True)

df.isnull().sum()

#Checking for duplicated values
df[df.duplicated(subset = df.columns, keep = False)]

#Looking for rows where Tenure is equal to 0.
df.loc[df["Tenure"] == 0]

#Removing all rows where Tenure is equal to 0.
df = df.loc[df["Tenure"] > 0]

#Visualizing the number of customers by Internet Service type.
plt.figure(figsize = (7,6))

ax = sns.countplot(x = df["InternetService"],
              palette = "viridis")
for p in ax.patches:
    height = p.get_height()
    ax.annotate(f'{height/len(df):.2%}',
                (p.get_x() + p.get_width()/2., height),
                ha='center', va='bottom')
plt.xlabel("Internet Service")
plt.ylabel("Count")
plt.title("Internet Service Count")
plt.grid(True)
plt.tight_layout()
plt.show()

#Visualizing the average churn rate based on Tech Support availability.
plt.figure(figsize=(9,6))
df["Churn Numeric"] = df["Churn"].map({"Yes": 1, "No": 0})

sns.barplot(
    data=df,
    x="TechSupport",
    y="Churn Numeric",
    palette="viridis",
    edgecolor="black")

plt.title("Average Churn Rate by Tech Support", fontsize=16, fontweight='bold')
plt.xlabel("Tech Support Availability", fontsize=13)
plt.ylabel("Average Churn Rate", fontsize=13)

plt.tight_layout()
plt.show()

df.describe()

numeric_col_data = df.select_dtypes(include = ["number"])

numeric_col_data

#Visualizing the distribution of numeric features using boxplots.
fig, axes = plt.subplots(2,2, figsize = (14,10))

sns.boxplot(data = df,
            x = "Age",
            ax = axes[0,0],
            color = "skyblue")
axes[0,0].set_title("Age", fontweight="bold")

sns.boxplot(data = df,
            x = "Tenure",
            ax = axes[0,1],
            color = "orange")
axes[0,1].set_title("Tenure", fontweight="bold")

sns.boxplot(data = df,
            x = "MonthlyCharges",
            ax = axes[1,0],
            color = "salmon")
axes[1,0].set_title("MonthlyCharges", fontweight="bold")

sns.boxplot(data = df,
            x = "TotalCharges",
            ax = axes[1,1],
            color = "crimson")

axes[1,1].set_title("TotalCharges", fontweight="bold")

plt.suptitle("Customer Churn Spread of Numerical Features", fontsize=16, fontweight="bold")
plt.tight_layout()
plt.show()

#Creating an heatmap and visualizing the correlation between numeric features.

plt.figure(figsize = (10,8))
sns.heatmap(numeric_col_data.corr(),
            annot = True,
            cmap = "icefire")
plt.show()

#Vsualizing the distribution of churned vs. non-churned customers.
plt.figure(figsize = (8,6))

sns.countplot(data = df,
              x = "Churn",
              palette = "mako")

plt.tight_layout()
plt.grid(True)
plt.title("CHURN Countplot")
plt.ylabel("Count")
plt.xlabel("Yes - No")
plt.show()

cmc = df.groupby("Churn")["MonthlyCharges"].mean()
cmc

cgmc = df.groupby(["Churn","Gender"])["MonthlyCharges"].mean()
cgmc

ct = df.groupby("Churn")["Tenure"].mean()
ct

ca = df.groupby("Churn")["Age"].mean()
ca

#Comparing key numeric features (Monthly Charges, Tenure, Age) with Churn and visualizing gender differences for Monthly Charges
#using multiple bar plots to spot patterns and differences between churned and non-churned customers.

fig, axes = plt.subplots(2,2, figsize = (17,10))

sns.barplot(data = cgmc.reset_index(),
            x = "Churn",
            y = "MonthlyCharges",
            hue = "Gender",
            ax = axes[0,0],
            palette = "tab10",
            edgecolor = "black")
axes[0,0].grid(True)
axes[0,0].set_title("Monthly Charges by Churn and Gender")

sns.barplot(data = cmc.reset_index(),
            x = "Churn",
            y = "MonthlyCharges",
            ax = axes[0,1],
            palette = "tab10",
            edgecolor = "black")
axes[0,1].grid(True)
axes[0,1].set_title("Monthly Charges by Churn")

sns.barplot(data = ct.reset_index(),
              x = "Churn",
              y = "Tenure",
              ax = axes[1,0],
              palette = "tab10",
              edgecolor = "black")
axes[1,0].grid(True)
axes[1,0].set_title("Tenure by Churn")

sns.barplot(data = ca.reset_index(),
              x = "Churn",
              y = "Age",
              ax = axes[1,1],
              palette = "tab10",
              edgecolor = "black")
axes[1,1].grid(True)
axes[1,1].set_title("Age by Churn")

plt.tight_layout()
plt.show()

contract_type_mc =  df.groupby("ContractType")["MonthlyCharges"].mean()

#Showing the average monthly charges for each contract type using a bar plot to see how contract plans affect customer pricing.
plt.figure(figsize = (8,6))

sns.barplot(x = contract_type_mc.index,
            y = contract_type_mc.values,
            palette = 'viridis')

plt.grid(True)
plt.xlabel("Contract Type")
plt.ylabel("Mean Price")
plt.title("Contract Type AVG Price")
plt.tight_layout()
plt.show()

#Visualizing the distribution of Monthly Charges to see how customer prices are spread across different values.
plt.figure(figsize = (8,6))

sns.histplot(data = df,
             x = "MonthlyCharges",
             palette = "viridis")
plt.title("Histogram of Monthly Charges")
plt.show()

#Visualizing the distribution of customer Tenure to see how long customers have been with the company.

plt.figure(figsize = (8,6))

sns.histplot(data = df,
             x = df["Tenure"],
             color="skyblue",
             edgecolor="black")
plt.title("Distribution of Customer Tenure")
plt.show()

#Creating and visualizing pairplots to comprehend data deeply.
sns.pairplot(df[["Age", "Tenure", "MonthlyCharges", "Churn"]],
             hue="Churn",
             palette = "bright")
plt.show()

df.columns

#Converting categorical columns to numerical data:
#Male/Female to 0/1 and No/Yes Churn to 0/1 for modeling purposes.
df["Gender Features"] = df["Gender"].map({"Male":0, "Female":1})
df["Churn Features"] = df["Churn"].map({"No":0, "Yes":1})

# Defining features x and target y for modeling.
y = df["Churn Features"]
x = df[["Age","Gender Features","Tenure","MonthlyCharges"]]

#Splitting the data into training and testing sets 80% train, 20% test for model evaluation.
from sklearn.model_selection import train_test_split
X_train, X_test, y_train, y_test = train_test_split(x, y, test_size = 0.2, random_state = 42)

#Importing standardscaler.
from sklearn.preprocessing import StandardScaler
scaler = StandardScaler()

#Scaling numeric features using StandardScaler so all feature values are on a similar scale.
X_train = scaler.fit_transform(X_train)
X_test = scaler.transform(X_test)

X_train

X_test

# Importing Logistic Regression and evaluation metrics,
# and defining a function to print key model performance scores (Precision, Recall, Accuracy, F1, AUC) for the test set
from sklearn.linear_model import LogisticRegression
from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score, roc_auc_score

def model_metrics(predictions):
  print("The precision of the model is {}".format(precision_score(y_test, predictions)))
  print("The recall of the model is {}".format(recall_score(y_test, predictions)))
  print("The Accuracy Score of model is {}".format(accuracy_score(y_test,predictions)))
  print("The F1 Score of model is {}".format(f1_score(y_test, predictions)))
  print("The AUC Score of model is {}".format(roc_auc_score(y_test, predictions)))
  return None

log_model = LogisticRegression()

#Training the Logistic Regression model on the training data.
log_model.fit(X_train, y_train)

#Testing the log model.
log_model.predict([[50,0,30,90]])

#Using the trained Logistic Regression model to make predictions on the test set.
y_pred  = log_model.predict(X_test)

y_test

#Evaluating the model by printing a detailed classification report precision, recall, f1-score and a confusion matrix for the test set.
from sklearn.metrics import classification_report, confusion_matrix
print(classification_report(y_test, y_pred))

#Visualizing the confusion matrix as a heatmap to see how well the model predicted churn vs. non-churn customers.
cm = confusion_matrix(y_test, y_pred)

plt.figure(figsize=(10,8))
sns.heatmap(cm,
            annot=True,
            fmt='d',
            cmap='icefire')
plt.xlabel('Predicted')
plt.ylabel('Actual')
plt.title('Confusion Matrix')
plt.show()

from sklearn.ensemble import RandomForestClassifier, GradientBoostingClassifier
from sklearn.svm import SVC

#Creating a dictionary of different machine learning models to compare their performance on predicting customer churn.
models = {"Logistic Regression": LogisticRegression(),
          "Random Forest": RandomForestClassifier(),
          "Gradient Boosting": GradientBoostingClassifier(),
          "SVM": SVC()}

#Training each model on the training data, making predictions on the test set, and printing their accuracy for a quick performance comparison.
for name, model in models.items():
    model.fit(X_train, y_train)
    preds = model.predict(X_test)
    print(f"{name} Accuracy: {accuracy_score(y_test, preds):.2f}")

#Using the previously defined function to print all key performance metrics incorporating Precision, Recall, Accuracy, F1, AUC for the predictions.
model_metrics(y_pred)